/* tslint:disable */
/* eslint-disable */
/**
 * BierLijst
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BodyCreateUserOpenApiUserOpenPost
 */
export interface BodyCreateUserOpenApiUserOpenPost {
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiUserOpenPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiUserOpenPost
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiUserOpenPost
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiUserOpenPost
     */
    full_name?: string;
}
/**
 * 
 * @export
 * @interface BodyUpdateUserMeApiUserMePut
 */
export interface BodyUpdateUserMeApiUserMePut {
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiUserMePut
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiUserMePut
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiUserMePut
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiUserMePut
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface Change
 */
export interface Change {
    /**
     * 
     * @type {number}
     * @memberof Change
     */
    container?: number;
    /**
     * 
     * @type {number}
     * @memberof Change
     */
    consumable?: number;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface ItemCreate
 */
export interface ItemCreate {
    /**
     * 
     * @type {string}
     * @memberof ItemCreate
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ItemCreate
     */
    container_size?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemCreate
     */
    is_active?: boolean;
}
/**
 * 
 * @export
 * @interface ItemUpdate
 */
export interface ItemUpdate {
    /**
     * 
     * @type {string}
     * @memberof ItemUpdate
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemUpdate
     */
    container_size?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemUpdate
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdate
     */
    id: string;
}
/**
 * 
 * @export
 * @interface PersonCreate
 */
export interface PersonCreate {
    /**
     * 
     * @type {string}
     * @memberof PersonCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PersonCreate
     */
    color?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PersonCreate
     */
    is_active?: boolean;
    /**
     * 
     * @type {object}
     * @memberof PersonCreate
     */
    balance?: object;
}
/**
 * 
 * @export
 * @interface PersonInDB
 */
export interface PersonInDB {
    /**
     * 
     * @type {string}
     * @memberof PersonInDB
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonInDB
     */
    color?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PersonInDB
     */
    is_active?: boolean;
    /**
     * 
     * @type {object}
     * @memberof PersonInDB
     */
    balance?: object;
    /**
     * 
     * @type {string}
     * @memberof PersonInDB
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonInDB
     */
    userid?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    access_token: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token_type: string;
}
/**
 * 
 * @export
 * @interface TransactionCreate
 */
export interface TransactionCreate {
    /**
     * 
     * @type {number}
     * @memberof TransactionCreate
     */
    timestamp?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreate
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreate
     */
    itemid: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreate
     */
    personid: string;
    /**
     * 
     * @type {Change}
     * @memberof TransactionCreate
     */
    change: Change;
}
/**
 * 
 * @export
 * @interface TransactionUpdate
 */
export interface TransactionUpdate {
    /**
     * 
     * @type {number}
     * @memberof TransactionUpdate
     */
    timestamp?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionUpdate
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdate
     */
    itemid?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdate
     */
    personid?: string;
    /**
     * 
     * @type {object}
     * @memberof TransactionUpdate
     */
    change?: object;
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdate
     */
    id: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    full_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    is_verified?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    is_premium?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface UserBase
 */
export interface UserBase {
    /**
     * 
     * @type {string}
     * @memberof UserBase
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBase
     */
    full_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserBase
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserBase
     */
    is_verified?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserBase
     */
    is_premium?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserBase
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Item
         * @param {ItemCreate} itemCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemApiItemPost: async (itemCreate: ItemCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemCreate' is not null or undefined
            assertParamExists('addItemApiItemPost', 'itemCreate', itemCreate)
            const localVarPath = `/api/item/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(itemCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiItemDelete: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteItemApiItemDelete', 'itemId', itemId)
            const localVarPath = `/api/item/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsApiItemGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/item/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {ItemUpdate} itemUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiItemPut: async (itemUpdate: ItemUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemUpdate' is not null or undefined
            assertParamExists('updateItemApiItemPut', 'itemUpdate', itemUpdate)
            const localVarPath = `/api/item/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(itemUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Item
         * @param {ItemCreate} itemCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addItemApiItemPost(itemCreate: ItemCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addItemApiItemPost(itemCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiItemDelete(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiItemDelete(itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsApiItemGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsApiItemGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Item
         * @param {ItemUpdate} itemUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiItemPut(itemUpdate: ItemUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiItemPut(itemUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Item
         * @param {ItemCreate} itemCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemApiItemPost(itemCreate: ItemCreate, options?: any): AxiosPromise<any> {
            return localVarFp.addItemApiItemPost(itemCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiItemDelete(itemId: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteItemApiItemDelete(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsApiItemGet(options?: any): AxiosPromise<any> {
            return localVarFp.getItemsApiItemGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {ItemUpdate} itemUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiItemPut(itemUpdate: ItemUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.updateItemApiItemPut(itemUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemApi - interface
 * @export
 * @interface ItemApi
 */
export interface ItemApiInterface {
    /**
     * 
     * @summary Add Item
     * @param {ItemCreate} itemCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    addItemApiItemPost(itemCreate: ItemCreate, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Delete Item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    deleteItemApiItemDelete(itemId: string, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Get Items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    getItemsApiItemGet(options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Update Item
     * @param {ItemUpdate} itemUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    updateItemApiItemPut(itemUpdate: ItemUpdate, options?: any): AxiosPromise<any>;

}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI implements ItemApiInterface {
    /**
     * 
     * @summary Add Item
     * @param {ItemCreate} itemCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public addItemApiItemPost(itemCreate: ItemCreate, options?: any) {
        return ItemApiFp(this.configuration).addItemApiItemPost(itemCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public deleteItemApiItemDelete(itemId: string, options?: any) {
        return ItemApiFp(this.configuration).deleteItemApiItemDelete(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItemsApiItemGet(options?: any) {
        return ItemApiFp(this.configuration).getItemsApiItemGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {ItemUpdate} itemUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public updateItemApiItemPut(itemUpdate: ItemUpdate, options?: any) {
        return ItemApiFp(this.configuration).updateItemApiItemPut(itemUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessTokenApiLoginAccessTokenPost: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginAccessTokenApiLoginAccessTokenPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginAccessTokenApiLoginAccessTokenPost', 'password', password)
            const localVarPath = `/api/login/access-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType as any);
            }

            if (username !== undefined) {
                localVarFormParams.set('username', username as any);
            }

            if (password !== undefined) {
                localVarFormParams.set('password', password as any);
            }

            if (scope !== undefined) {
                localVarFormParams.set('scope', scope as any);
            }

            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId as any);
            }

            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret as any);
            }


            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testTokenApiLoginTestTokenPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login/test-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAccessTokenApiLoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAccessTokenApiLoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testTokenApiLoginTestTokenPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testTokenApiLoginTestTokenPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessTokenApiLoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.loginAccessTokenApiLoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testTokenApiLoginTestTokenPost(options?: any): AxiosPromise<UserBase> {
            return localVarFp.testTokenApiLoginTestTokenPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - interface
 * @export
 * @interface LoginApi
 */
export interface LoginApiInterface {
    /**
     * OAuth2 compatible token login, get an access token for future requests
     * @summary Login Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiInterface
     */
    loginAccessTokenApiLoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token>;

    /**
     * Test access token
     * @summary Test Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiInterface
     */
    testTokenApiLoginTestTokenPost(options?: any): AxiosPromise<UserBase>;

}

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI implements LoginApiInterface {
    /**
     * OAuth2 compatible token login, get an access token for future requests
     * @summary Login Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public loginAccessTokenApiLoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any) {
        return LoginApiFp(this.configuration).loginAccessTokenApiLoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test access token
     * @summary Test Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public testTokenApiLoginTestTokenPost(options?: any) {
        return LoginApiFp(this.configuration).testTokenApiLoginTestTokenPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PeopleApi - axios parameter creator
 * @export
 */
export const PeopleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add People
         * @param {Array<PersonCreate>} personCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPeopleApiPeoplePost: async (personCreate: Array<PersonCreate>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personCreate' is not null or undefined
            assertParamExists('addPeopleApiPeoplePost', 'personCreate', personCreate)
            const localVarPath = `/api/people/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(personCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete People
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePeopleApiPeopleDelete: async (requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deletePeopleApiPeopleDelete', 'requestBody', requestBody)
            const localVarPath = `/api/people/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get People
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeopleApiPeopleGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/people/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Person
         * @param {PersonInDB} personInDB 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonApiPeoplePut: async (personInDB: PersonInDB, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personInDB' is not null or undefined
            assertParamExists('updatePersonApiPeoplePut', 'personInDB', personInDB)
            const localVarPath = `/api/people/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(personInDB, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleApi - functional programming interface
 * @export
 */
export const PeopleApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add People
         * @param {Array<PersonCreate>} personCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPeopleApiPeoplePost(personCreate: Array<PersonCreate>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPeopleApiPeoplePost(personCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete People
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePeopleApiPeopleDelete(requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePeopleApiPeopleDelete(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get People
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeopleApiPeopleGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeopleApiPeopleGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Person
         * @param {PersonInDB} personInDB 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersonApiPeoplePut(personInDB: PersonInDB, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersonApiPeoplePut(personInDB, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PeopleApi - factory interface
 * @export
 */
export const PeopleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleApiFp(configuration)
    return {
        /**
         * 
         * @summary Add People
         * @param {Array<PersonCreate>} personCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPeopleApiPeoplePost(personCreate: Array<PersonCreate>, options?: any): AxiosPromise<any> {
            return localVarFp.addPeopleApiPeoplePost(personCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete People
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePeopleApiPeopleDelete(requestBody: Array<string>, options?: any): AxiosPromise<any> {
            return localVarFp.deletePeopleApiPeopleDelete(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get People
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeopleApiPeopleGet(options?: any): AxiosPromise<any> {
            return localVarFp.getPeopleApiPeopleGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Person
         * @param {PersonInDB} personInDB 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonApiPeoplePut(personInDB: PersonInDB, options?: any): AxiosPromise<any> {
            return localVarFp.updatePersonApiPeoplePut(personInDB, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleApi - interface
 * @export
 * @interface PeopleApi
 */
export interface PeopleApiInterface {
    /**
     * 
     * @summary Add People
     * @param {Array<PersonCreate>} personCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApiInterface
     */
    addPeopleApiPeoplePost(personCreate: Array<PersonCreate>, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Delete People
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApiInterface
     */
    deletePeopleApiPeopleDelete(requestBody: Array<string>, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Get People
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApiInterface
     */
    getPeopleApiPeopleGet(options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Update Person
     * @param {PersonInDB} personInDB 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApiInterface
     */
    updatePersonApiPeoplePut(personInDB: PersonInDB, options?: any): AxiosPromise<any>;

}

/**
 * PeopleApi - object-oriented interface
 * @export
 * @class PeopleApi
 * @extends {BaseAPI}
 */
export class PeopleApi extends BaseAPI implements PeopleApiInterface {
    /**
     * 
     * @summary Add People
     * @param {Array<PersonCreate>} personCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public addPeopleApiPeoplePost(personCreate: Array<PersonCreate>, options?: any) {
        return PeopleApiFp(this.configuration).addPeopleApiPeoplePost(personCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete People
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public deletePeopleApiPeopleDelete(requestBody: Array<string>, options?: any) {
        return PeopleApiFp(this.configuration).deletePeopleApiPeopleDelete(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get People
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public getPeopleApiPeopleGet(options?: any) {
        return PeopleApiFp(this.configuration).getPeopleApiPeopleGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Person
     * @param {PersonInDB} personInDB 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public updatePersonApiPeoplePut(personInDB: PersonInDB, options?: any) {
        return PeopleApiFp(this.configuration).updatePersonApiPeoplePut(personInDB, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Transaction
         * @param {TransactionCreate} transactionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTransactionApiTransactionPost: async (transactionCreate: TransactionCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionCreate' is not null or undefined
            assertParamExists('addTransactionApiTransactionPost', 'transactionCreate', transactionCreate)
            const localVarPath = `/api/transaction/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionApiTransactionDelete: async (transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('deleteTransactionApiTransactionDelete', 'transactionId', transactionId)
            const localVarPath = `/api/transaction/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (transactionId !== undefined) {
                localVarQueryParameter['transaction_id'] = transactionId;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transactions
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsApiTransactionGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/transaction/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleTransactionApiTransactionTogglePut: async (transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('toggleTransactionApiTransactionTogglePut', 'transactionId', transactionId)
            const localVarPath = `/api/transaction/toggle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (transactionId !== undefined) {
                localVarQueryParameter['transaction_id'] = transactionId;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Transaction
         * @param {TransactionUpdate} transactionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionApiTransactionPut: async (transactionUpdate: TransactionUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionUpdate' is not null or undefined
            assertParamExists('updateTransactionApiTransactionPut', 'transactionUpdate', transactionUpdate)
            const localVarPath = `/api/transaction/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Transaction
         * @param {TransactionCreate} transactionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTransactionApiTransactionPost(transactionCreate: TransactionCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTransactionApiTransactionPost(transactionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionApiTransactionDelete(transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransactionApiTransactionDelete(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Transactions
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsApiTransactionGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsApiTransactionGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Toggle Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleTransactionApiTransactionTogglePut(transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleTransactionApiTransactionTogglePut(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Transaction
         * @param {TransactionUpdate} transactionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransactionApiTransactionPut(transactionUpdate: TransactionUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransactionApiTransactionPut(transactionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Transaction
         * @param {TransactionCreate} transactionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTransactionApiTransactionPost(transactionCreate: TransactionCreate, options?: any): AxiosPromise<any> {
            return localVarFp.addTransactionApiTransactionPost(transactionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionApiTransactionDelete(transactionId: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteTransactionApiTransactionDelete(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transactions
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsApiTransactionGet(skip?: number, limit?: number, options?: any): AxiosPromise<any> {
            return localVarFp.getTransactionsApiTransactionGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleTransactionApiTransactionTogglePut(transactionId: string, options?: any): AxiosPromise<any> {
            return localVarFp.toggleTransactionApiTransactionTogglePut(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Transaction
         * @param {TransactionUpdate} transactionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionApiTransactionPut(transactionUpdate: TransactionUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.updateTransactionApiTransactionPut(transactionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - interface
 * @export
 * @interface TransactionApi
 */
export interface TransactionApiInterface {
    /**
     * 
     * @summary Add Transaction
     * @param {TransactionCreate} transactionCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiInterface
     */
    addTransactionApiTransactionPost(transactionCreate: TransactionCreate, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Delete Transaction
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiInterface
     */
    deleteTransactionApiTransactionDelete(transactionId: string, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Get Transactions
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiInterface
     */
    getTransactionsApiTransactionGet(skip?: number, limit?: number, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Toggle Transaction
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiInterface
     */
    toggleTransactionApiTransactionTogglePut(transactionId: string, options?: any): AxiosPromise<any>;

    /**
     * 
     * @summary Update Transaction
     * @param {TransactionUpdate} transactionUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApiInterface
     */
    updateTransactionApiTransactionPut(transactionUpdate: TransactionUpdate, options?: any): AxiosPromise<any>;

}

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI implements TransactionApiInterface {
    /**
     * 
     * @summary Add Transaction
     * @param {TransactionCreate} transactionCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public addTransactionApiTransactionPost(transactionCreate: TransactionCreate, options?: any) {
        return TransactionApiFp(this.configuration).addTransactionApiTransactionPost(transactionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Transaction
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public deleteTransactionApiTransactionDelete(transactionId: string, options?: any) {
        return TransactionApiFp(this.configuration).deleteTransactionApiTransactionDelete(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transactions
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getTransactionsApiTransactionGet(skip?: number, limit?: number, options?: any) {
        return TransactionApiFp(this.configuration).getTransactionsApiTransactionGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Transaction
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public toggleTransactionApiTransactionTogglePut(transactionId: string, options?: any) {
        return TransactionApiFp(this.configuration).toggleTransactionApiTransactionTogglePut(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Transaction
     * @param {TransactionUpdate} transactionUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public updateTransactionApiTransactionPut(transactionUpdate: TransactionUpdate, options?: any) {
        return TransactionApiFp(this.configuration).updateTransactionApiTransactionPut(transactionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiUserOpenPost} bodyCreateUserOpenApiUserOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserOpenApiUserOpenPost: async (bodyCreateUserOpenApiUserOpenPost: BodyCreateUserOpenApiUserOpenPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateUserOpenApiUserOpenPost' is not null or undefined
            assertParamExists('createUserOpenApiUserOpenPost', 'bodyCreateUserOpenApiUserOpenPost', bodyCreateUserOpenApiUserOpenPost)
            const localVarPath = `/api/user/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateUserOpenApiUserOpenPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update own user.
         * @summary Delete User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserMeApiUserMeDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMeApiUserMeGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiUserMePut} [bodyUpdateUserMeApiUserMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMeApiUserMePut: async (bodyUpdateUserMeApiUserMePut?: BodyUpdateUserMeApiUserMePut, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(bodyUpdateUserMeApiUserMePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiUserOpenPost} bodyCreateUserOpenApiUserOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserOpenApiUserOpenPost(bodyCreateUserOpenApiUserOpenPost: BodyCreateUserOpenApiUserOpenPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserOpenApiUserOpenPost(bodyCreateUserOpenApiUserOpenPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update own user.
         * @summary Delete User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserMeApiUserMeDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserMeApiUserMeDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserMeApiUserMeGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserMeApiUserMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiUserMePut} [bodyUpdateUserMeApiUserMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserMeApiUserMePut(bodyUpdateUserMeApiUserMePut?: BodyUpdateUserMeApiUserMePut, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserMeApiUserMePut(bodyUpdateUserMeApiUserMePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiUserOpenPost} bodyCreateUserOpenApiUserOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserOpenApiUserOpenPost(bodyCreateUserOpenApiUserOpenPost: BodyCreateUserOpenApiUserOpenPost, options?: any): AxiosPromise<User> {
            return localVarFp.createUserOpenApiUserOpenPost(bodyCreateUserOpenApiUserOpenPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Update own user.
         * @summary Delete User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserMeApiUserMeDelete(options?: any): AxiosPromise<User> {
            return localVarFp.deleteUserMeApiUserMeDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMeApiUserMeGet(options?: any): AxiosPromise<User> {
            return localVarFp.readUserMeApiUserMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiUserMePut} [bodyUpdateUserMeApiUserMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMeApiUserMePut(bodyUpdateUserMeApiUserMePut?: BodyUpdateUserMeApiUserMePut, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserMeApiUserMePut(bodyUpdateUserMeApiUserMePut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * Create new user without the need to be logged in.
     * @summary Create User Open
     * @param {BodyCreateUserOpenApiUserOpenPost} bodyCreateUserOpenApiUserOpenPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createUserOpenApiUserOpenPost(bodyCreateUserOpenApiUserOpenPost: BodyCreateUserOpenApiUserOpenPost, options?: any): AxiosPromise<User>;

    /**
     * Update own user.
     * @summary Delete User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserMeApiUserMeDelete(options?: any): AxiosPromise<User>;

    /**
     * Retrieve user.
     * @summary Read User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    readUserMeApiUserMeGet(options?: any): AxiosPromise<User>;

    /**
     * Update own user.
     * @summary Update User Me
     * @param {BodyUpdateUserMeApiUserMePut} [bodyUpdateUserMeApiUserMePut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUserMeApiUserMePut(bodyUpdateUserMeApiUserMePut?: BodyUpdateUserMeApiUserMePut, options?: any): AxiosPromise<User>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * Create new user without the need to be logged in.
     * @summary Create User Open
     * @param {BodyCreateUserOpenApiUserOpenPost} bodyCreateUserOpenApiUserOpenPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserOpenApiUserOpenPost(bodyCreateUserOpenApiUserOpenPost: BodyCreateUserOpenApiUserOpenPost, options?: any) {
        return UserApiFp(this.configuration).createUserOpenApiUserOpenPost(bodyCreateUserOpenApiUserOpenPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update own user.
     * @summary Delete User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserMeApiUserMeDelete(options?: any) {
        return UserApiFp(this.configuration).deleteUserMeApiUserMeDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve user.
     * @summary Read User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public readUserMeApiUserMeGet(options?: any) {
        return UserApiFp(this.configuration).readUserMeApiUserMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update own user.
     * @summary Update User Me
     * @param {BodyUpdateUserMeApiUserMePut} [bodyUpdateUserMeApiUserMePut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserMeApiUserMePut(bodyUpdateUserMeApiUserMePut?: BodyUpdateUserMeApiUserMePut, options?: any) {
        return UserApiFp(this.configuration).updateUserMeApiUserMePut(bodyUpdateUserMeApiUserMePut, options).then((request) => request(this.axios, this.basePath));
    }
}


